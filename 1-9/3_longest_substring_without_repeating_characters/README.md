### 题目描述
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

```
示例 1:

输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
 ```

### 基本思路
#### 暴力解法
暴力解法思路很简单，我们可以通过两个for循环。初始时，以第一个元素为左右边界，然后依次后移右边界，若右边界指向的值在前面没出现过，则继续右移，否则将左指针向右移动一步，将右指针放置到左指针下一个元素，重复上面操作。直到找到最长无重复子串。

#### 滑动窗口解法
在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引i到j - 1之间的子字符串 s[i: j]，已经被检查为没有重复字符，我们只需要检查s[j]对应的字符是否已经存在于子字符串s[i, j]​中即可。因此我们设计如下：
- 初始化左右指针为第一个元素
- 向右移动窗口右边界，若右边界未出现在遍历过的字典中，则求出当前最长子串长度（右边界-左边界+1）；如果出现在字典中，则直接将左边界移动到右边界+1
- 每次遍历后，都将遍历过的右边界所指向的值加入字典，键为该字符，值为当前索引。
举个栗子，针对abcab，i为左指针, j为右指针, dic为字典, str为当前子串, ans为最长子串长度
- i=0   j=0 str=a   ans=1   dic={'a': 0}
- i=0   j=1 str=ab  ans=2   dic={'a': 0, 'b': 1}
- i=0   j=2 str=abc ans=3   dic={'a': 0, 'b': 1, 'c': 2}
- i=0   j=3 str=abc 不计算ans   dic={'a': 0, 'b': 1, 'c': 2}
- i=1   j=4 str=bca 不计算ans   dic={'a': 3, 'b': 4, 'c': 2}

#### 实现代码
仅列出滑动窗口解法，暴力解法见文件
```python
def lengthOfLongestSubstring(self, s):
    """
    :type s: str
    :rtype: int
    """
    # 滑动窗口
    window_dict = {}
    # 滑动窗口左右索引
    i = j = 0
    # 子串长度
    ans = 0
    # 字符串长度
    length = len(s)
    for j in range(len(s)):
        if s[j] in window_dict and i <= window_dict.get(s[j]):
            i = window_dict[s[j]] + 1
        # 如果没有处于滑动窗口中
        else:
            ans = max(ans, j - i + 1)
        window_dict[s[j]] = j
    return ans
```